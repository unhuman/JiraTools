# Service Consumer Analysis Documentation

## Overview

`serviceConsumerAnalysis.py` is a powerful tool for analyzing service-to-service communication patterns in your microservices architecture using Datadog trace data. It identifies which services are calling your team's applications and generates comprehensive reports organized by domain with consumers grouped by product.

The tool takes team application attribution data (from `teamApplicationAttribution.py`) and queries Datadog's APM traces to discover consumption patterns, helping you understand:
- Which products/business areas are consuming your services
- Which of your internal systems receive the most traffic
- Cross-domain dependencies and communication patterns
- External service usage that may need mapping

**Key Feature**: Reports are organized by **domain** (one file per domain), but within each report, consumers are intelligently grouped by their **product** (with automatic fallback to domain if no product is defined).

## Prerequisites

1. **Python 3.x** with required packages:
   - `requests` - HTTP client for Datadog API
   - `colorama` - Colored terminal output

2. **Datadog Access**:
   - API Key and Application Key, OR
   - Valid authentication cookies

3. **Input Data**:
   - `allTeamApplications.json` - Generated by `teamApplicationAttribution.py`
   - `.datadog.cfg` - Configuration file (optional but recommended)

## Command Line Usage

### Basic Syntax

```bash
python serviceConsumerAnalysis.py <input_file> <environment> <datadog_host> [auth_options] [filters]
```

### Parameters

- **`<input_file>`** (required): Path to the JSON file containing team application attribution data
- **`<environment>`** (required): Datadog environment to query (e.g., `production`, `staging`)
- **`<datadog_host>`** (required): Your Datadog site URL (e.g., `https://company.datadoghq.com`)

### Authentication Options

Choose one of the following:

#### Option 1: API Keys (Recommended)
```bash
--api-key <YOUR_API_KEY> --app-key <YOUR_APP_KEY>
```

#### Option 2: Configuration File (Most Convenient)
If you omit `--api-key` and `--app-key`, credentials are automatically read from `~/.datadog.cfg`

#### Option 3: Cookie Authentication
```bash
--cookies "<cookie_string>"
```
Cookies should be semicolon-separated (e.g., `"_dd_did=...; datadog-theme=light"`)

### Optional Filters

- **`-t, --teams <TEAMS>`**: Process only specific teams (comma-separated)
  ```bash
  -t "team1,team2,team3"
  ```

- **`-a, --applications <APPS>`**: Process only specific applications (comma-separated)
  ```bash
  -a "service-a,service-b"
  ```

### Additional Options

- **`--time-period <PERIOD>`**: Time window for analysis (default: `1h`)
  - Valid values: `1h`, `4h`, `1d`, `1w`, `2w`, etc.
  ```bash
  --time-period 2w
  ```

- **`--preserve-rate-limit <N>`**: Number of API requests to preserve from rate limit (default: `1`)
  ```bash
  --preserve-rate-limit 0  # Use full rate limit
  ```

- **`--nocache`**: Disable reading from cache (still writes to cache for future runs)
  - Forces fresh API requests even if cached data exists
  - Useful when you need the most current data or suspect cache is stale
  ```bash
  --nocache
  ```

- **`--ignoreCacheExpiry`**: Use cached data without checking expiration time
  - Reads and uses cache even if older than 24 hours
  - Useful for analyzing historical data or reproducing past analysis
  - Does not query Datadog API, relies entirely on cached responses
  - Helpful when rate limits are a concern or API is unavailable
  ```bash
  --ignoreCacheExpiry
  ```

- **`--output <FILE>`**: Custom name for the summary report (default: `multiple_teams_report.json`)
  ```bash
  --output custom_report.json
  ```

- **`--excludeSpecifiedTeamRequests`**: When teams are specified (via `--teams` or config file), excludes requests from services owned by those teams from all reporting and analysis
  - Only valid when teams are specified (command line or config file)
  - Useful for focusing analysis on external consumers or avoiding internal cross-team traffic
  - Any request from a service owned by one of the specified teams is ignored/excluded during processing
  ```bash
  --teams "team1,team2" --excludeSpecifiedTeamRequests
  # Or if teams are in config file:
  --excludeSpecifiedTeamRequests
  ```

- **`--excludeProducts`**: Exclude specified product/platform/domain names from totals, comma-separated
  - Excluded products will appear in reports with `percentage: 0.0` and their traffic shown in `excluded_count`
  - Useful for filtering out noise, internal products, or specific categories from percentage calculations
  - Case-insensitive matching
  ```bash
  --excludeProducts "External/Unknown,product-name-1,product-name-2"
  ```

### Examples

**1. Basic usage with config file authentication:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com
```

**2. Analyze specific teams with 2-week time window:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com \
  --time-period 2w \
  --teams "team1,team2,team3"
```

**3. Single application analysis with explicit API keys:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com \
  --api-key YOUR_API_KEY \
  --app-key YOUR_APP_KEY \
  -a "service-a"
```

**4. Using cookie authentication:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com \
  --cookies "_dd_did=...; datadog-theme=light; dogweb=..."
```

**5. Force fresh data by disabling cache:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com \
  --nocache
```

**6. Use expired cache data for historical analysis:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com \
  --ignoreCacheExpiry
```

**7. Analyze specific teams, excluding their own requests:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com \
  --teams "team1,team2" \
  --excludeSpecifiedTeamRequests
```

**8. Use teams from config file and exclude their requests:**
```bash
# Assumes teams are defined in ~/.datadog.cfg
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com \
  --excludeSpecifiedTeamRequests
```

## Configuration File: ~/.datadog.cfg

The `.datadog.cfg` file is a JSON configuration file stored in your home directory that provides credentials, service mappings, and advanced configuration options.

### File Location
```
~/.datadog.cfg
```

### Configuration Structure

```json
{
  "api-key": "your_datadog_api_key",
  "app-key": "your_datadog_app_key",
  "application-alias": {
    "service1": "service2",
    "another-service": "canonical-service"
  },
  "skip-applications": [
    "test-service",
    "deprecated-service",
    "internal-tool"
  ],
  "teams": [
    "team1",
    "team2",
    "team3"
  ],
  "excludeSpecifiedTeamRequests": false,
  "application-assignments": [
    {
      "name": "external-service-name",
      "business-unit": "business-unit-name",
      "domain": "domain-name",
      "platform": "platform-name",
      "product": null,
      "system": null
    }
  ]
}
```

### Configuration Sections

#### 1. Authentication (Required)
```json
{
  "api-key": "your_datadog_api_key",
  "app-key": "your_datadog_app_key"
}
```
- Stores your Datadog API credentials
- Eliminates need to pass credentials on command line

#### 2. Application Alias (Optional)
```json
{
  "application-alias": {
    "service-a-v2": "service-a",
    "service-b-alt": "service-b"
  }
}
```

**Purpose**: Maps service names to use metadata from another service while maintaining their original identity.

**Use Cases**:
- Service names in Datadog differ from canonical names
- Multiple services share the same team/domain metadata
- Temporary services that should map to permanent counterparts

**Behavior**:
- Lookup uses the aliased service's business-unit, domain, platform, product, and system data
- Reports still identify the service by its original name
- Alias resolution happens **after** application-assignments check

**Example**: If "service-a-v2" is aliased to "service-a":
- Service "service-a-v2" in Datadog traces
- Lookup finds "service-a" in attribution data
- Uses service-a's domain/team information
- Reports show "service-a-v2" as the service name

#### 3. Skip Applications (Optional)
```json
{
  "skip-applications": [
    "test-service",
    "deprecated-service",
    "internal-monitoring-tool"
  ]
}
```

**Purpose**: Completely exclude specified services from all processing and calculations.

**Behavior**:
- Services in this list are never queried
- Calls involving these services (as caller or callee) are ignored
- These services **do not affect** totals, percentages, or any aggregated data
- Useful for removing noise from reports

**Use Cases**:
- Test/development services in production traces
- Deprecated services being phased out
- Internal monitoring tools that skew metrics

#### 4. Teams (Optional)
```json
{
  "teams": [
    "team1",
    "team2",
    "team3"
  ]
}
```

**Purpose**: Specify a default list of teams to analyze when the `--teams` parameter is not provided on the command line.

**Behavior**:
- If `--teams` is provided on command line, it takes precedence
- If `--teams` is not provided, uses the teams list from config file
- If neither is provided, all teams in the input file are analyzed
- Team names are matched case-insensitively against team identifiers, team names, and team titles

**Use Cases**:
- Consistent team filtering across multiple runs
- Avoiding long command lines when analyzing the same teams repeatedly
- Standardizing analysis to specific teams without manual filtering

**Example Configuration**:
```json
{
  "teams": ["team1", "team2", "team3"]
}
```

With this configuration, running the script without `--teams` will automatically filter to these three teams, equivalent to running:
```bash
python serviceConsumerAnalysis.py ... --teams "team1,team2,team3"
```

#### 5. Exclude Specified Team Requests (Optional)
```json
{
  "excludeSpecifiedTeamRequests": true
}
```

**Purpose**: Set the default behavior for excluding requests from services owned by the specified teams when not provided on the command line.

**Behavior**:
- If `--excludeSpecifiedTeamRequests` is provided on command line, it takes precedence (always enabled)
- If `--excludeSpecifiedTeamRequests` is not provided, uses the value from config file (true/false)
- If neither is provided, defaults to false (include team requests)
- Only valid when teams are specified (via `--teams` parameter or "teams" in config file)
- When enabled, excludes any requests from services owned by the specified teams from all reporting and analysis

**Use Cases**:
- Always exclude internal team traffic in analyses to focus on external consumers
- Consistent behavior across multiple runs without needing to specify the flag each time
- Standardizing team-focused analysis to only show external dependencies

**Example Configuration**:
```json
{
  "teams": ["team1", "team2"],
  "excludeSpecifiedTeamRequests": true
}
```

With this configuration, running the script will automatically exclude requests from team1 and team2 services, equivalent to running:
```bash
python serviceConsumerAnalysis.py ... --teams "team1,team2" --excludeSpecifiedTeamRequests
```

#### 6. Exclude Products (Optional)
```json
{
  "exclude-products": [
    "External/Unknown",
    "product-name-1",
    "product-name-2"
  ]
}
```

**Purpose**: Set the default list of product/platform/domain names to exclude from totals when not provided on the command line.

**Behavior**:
- If `--excludeProducts` is provided on command line, it takes precedence
- If `--excludeProducts` is not provided, uses the value from config file
- If neither is provided, no products are excluded (all included in totals)
- Case-insensitive matching against product/platform/domain grouping names
- Excluded products appear in reports with `percentage: 0.0` and traffic shown in `excluded_count`

**Use Cases**:
- Filter out External/Unknown services from percentage calculations
- Exclude internal infrastructure products to focus on business product consumption
- Consistent exclusion across multiple runs without command line flags

**Example Configuration**:
```json
{
  "exclude-products": [
    "External/Unknown",
    "internal-infrastructure",
    "monitoring-tools"
  ]
}
```

With this configuration, these products will be excluded from percentage calculations but still visible in reports with their traffic shown as `excluded_count`.

#### 7. Map Products (Optional)
```json
{
  "map-products": {
    "source-product-1": "target-product-1",
    "source-product-2": "target-product-2",
    "snapshots": "event"
  }
}
```

**Purpose**: Remap one product grouping to another product, consolidating traffic from multiple product names into a single target product.

**Behavior**:
- Applied AFTER product determination but BEFORE aggregation
- Source product name (key) is case-insensitive
- Target product name (value) is case-insensitive
- All traffic from source product is added to target product's totals
- Details preserve original calling service names
- Source product will not appear in final reports (fully merged into target)

**Use Cases**:
- Consolidate closely related products (e.g., merge "snapshots" into "event")
- Rename products without updating attribution data
- Combine legacy and new product names during transitions
- Group test/staging variants with production products

**Example Configuration**:
```json
{
  "map-products": {
    "snapshots": "event",
    "legacy-product": "new-product-name",
    "product-staging": "product"
  }
}
```

With this configuration:
- All traffic to services in the "snapshots" product will be counted as "event" product traffic
- The "snapshots" product will not appear separately in reports
- Percentages are calculated based on the merged totals

**Important Notes**:
- Mapping happens before exclusion checks, so you can map to an excluded product
- If both source and target exist separately, all traffic is consolidated under the target name
- Mapping is one-way only (source → target); for multiple sources to one target, add multiple entries

#### 8. Application Assignments (Optional)
```json
{
  "application-assignments": [
    {
      "name": "external-library",
      "business-unit": "shared",
      "domain": "External/Unknown",
      "platform": "external",
      "product": null,
      "system": null
    },
    {
      "name": "third-party-service",
      "business-unit": "shared",
      "domain": "Domain A",
      "platform": "platform-x",
      "product": "product-y",
      "system": "system-z",
      "team": "team-identifier"
    }
  ]
}
```

**Purpose**: Provides explicit domain/team assignments for services not found in attribution data.

**Priority**: **Checked FIRST** before attempting fuzzy matching or attribution data lookup.

**Fields**:
- **`name`** (required): Service name to match
- **`business-unit`**: Business unit assignment
- **`domain`**: Domain assignment
- **`platform`**: Platform assignment (used for product grouping fallback)
- **`product`**: Product assignment (used for product grouping)
- **`system`**: System assignment
- **`team`**: Team identifier (used for team exclusion when `excludeSpecifiedTeamRequests` is enabled)

**Use Cases**:
- External services not in your team application catalog
- Third-party integrations (libraries, SDKs, monitoring tools, etc.)
- Services that fuzzy matching cannot resolve
- Override incorrect attribution data

**Behavior**:
1. When a service is encountered, check application-assignments first
2. If found, use the configured metadata immediately
3. If not found, proceed with fuzzy matching against attribution data
4. If still not found, mark as "External/Unknown"

**Team Exclusion**:
When `excludeSpecifiedTeamRequests` is enabled and teams are specified:
- If a service has a `team` field in application-assignments, that team is checked against excluded teams
- Services from excluded teams (matched via application-assignments or attribution data) are excluded from totals
- This allows external services to be explicitly assigned to teams for proper exclusion handling

**Example with Team Exclusion**:
```json
{
  "teams": ["identity", "platform"],
  "excludeSpecifiedTeamRequests": true,
  "application-assignments": [
    {
      "name": "external-auth-library",
      "business-unit": "shared",
      "domain": "External/Unknown",
      "platform": "external",
      "product": null,
      "system": null,
      "team": "identity"
    }
  ]
}
```

In this example, when analyzing with teams `["identity", "platform"]`, the service `external-auth-library` will be excluded from totals because it's assigned to the "identity" team via application-assignments.

### Complete Configuration Example

Here's a comprehensive example showing all available configuration options in `~/.datadog.cfg`:

```json
{
  "api-key": "your_datadog_api_key",
  "app-key": "your_datadog_app_key",
  "application-alias": {
    "old-service-name": "new-service-name",
    "service-variant-a": "canonical-service",
    "legacy-name": "current-name"
  },
  "skip-applications": [
    "test-harness",
    "deprecated-service",
    "internal-tool"
  ],
  "desired-end-categorizations": [
    "event.*",
    "registration",
    "^billing$",
    "payments"
  ],
  "remap-categorizations": {
    "old-product-name": "new-product-name",
    "variant-1": "consolidated-product",
    "variant-2": "consolidated-product"
  },
  "teams": [
    "identity",
    "infrastructure",
    "platform"
  ],
  "excludeSpecifiedTeamRequests": true,
  "exclude-products": [
    "External/Unknown",
    "internal-tools",
    "monitoring"
  ],
  "map-products": {
    "snapshots": "event",
    "legacy-product": "current-product",
    "test-platform": "platform"
  },
  "application-assignments": [
    {
      "name": "external-library",
      "business-unit": "shared",
      "domain": "External/Unknown",
      "platform": "external",
      "product": null,
      "system": null,
      "team": null
    },
    {
      "name": "third-party-api",
      "business-unit": "shared",
      "domain": "integrations",
      "platform": "external-apis",
      "product": "third-party",
      "system": "api-gateway",
      "team": "platform"
    }
  ]
}
```

This configuration:
- Authenticates with Datadog using API keys
- Normalizes 3 service name variants to canonical names
- Skips 3 test/deprecated services from all processing
- Prioritizes 4 product patterns for grouping
- Consolidates 3 old product names into 2 new ones
- Excludes traffic from 3 specified teams
- Excludes 3 products from percentage calculations
- Maps 3 source products to their target products
- Provides explicit assignments for 2 external services (including team assignment for exclusion)

## Input Data: allTeamApplications.json

This file is generated by `teamApplicationAttribution.py` and contains your organization's team and application structure.

### File Structure

```json
{
  "team-identifier": {
    "team_name": "team-identifier",
    "team_title": "Team Display Name",
    "domain": "Domain Name",
    "business_unit": "business-unit-name",
    "applications": [
      {
        "name": "service-name",
        "title": "Service Display Title",
        "type": "application",
        "lifecycle": "active",
        "system": "system-name",
        "platform": "platform-name",
        "product": "product-name",
        "business_unit": "business-unit-name",
        "description": "Service description"
      }
    ]
  }
}
```

### Key Fields

- **`team_name`**: Unique team identifier
- **`team_title`**: Human-readable team name
- **`domain`**: Business domain the team belongs to
- **`business_unit`**: Higher-level organizational grouping
- **`applications`**: Array of services owned by the team
  - **`name`**: Service name (used for matching with Datadog)
  - **`title`**: Display name for the service
  - **`system`**: System the service belongs to within the domain
  - **`lifecycle`**: Service lifecycle status (active, deprecated, etc.)

### Service Name Matching

The tool uses intelligent fuzzy matching to resolve Datadog service names to attribution data:

1. **Exact match**: Direct name match
2. **Suffix removal**: Tries removing common suffixes:
   - `-service`
   - `-http-client`
   - `-lambda`
3. **Character substitution**: Replaces dashes with spaces
4. **Title matching**: Checks against the service `title` field
5. **Case-insensitive**: All matches are case-insensitive
6. **Alias resolution**: Applies application-alias mappings

**Example Matches**:
- `service-a-v2` → `service-a` (exact match or suffix removal)
- `service-b` → `service-b` (exact match)
- `service-c-http-client` → `service-c` (suffix removal)
- `service-d-lambda` → `service-d` (suffix removal)

## Output Reports

The tool generates JSON reports with two main views of your service consumption patterns. Reports are organized by **domain** (one file per domain), with consumers intelligently grouped by their **product** (or domain if no product is defined).

### Report Types

#### 1. Domain Reports (`domain_reports`)
Shows **WHO is calling your services**, organized by the target domain with consumers grouped by their product.

**Structure**:
```json
{
  "Target Domain": {
    "Consumer Product": {
      "count": 1000,
      "percentage": 30.5,
      "details": [
        {
          "target_service": "your-service",
          "calling_service": "their-service",
          "count": 500
        }
      ]
    }
  }
}
```

**Key Feature**: Consumers are grouped by their **product** (e.g., "billing", "event-management") if available. If a consuming service doesn't have a product defined, it falls back to the **domain** (e.g., "Analytics", "Platform").

**Use Cases**:
- Understanding which products/business areas depend on your services
- Identifying cross-product dependencies
- Planning API changes and deprecations based on product impact
- Capacity planning based on consumer patterns

#### 2. System Reports (`system_reports`)
Shows **WHICH of your systems are being called**, aggregated by system within your domain.

**Structure**:
```json
{
  "Target Domain": {
    "System Name": {
      "count": 5000,
      "percentage": 45.2,
      "services": [
        {
          "service": "service-x",
          "count": 3000
        }
      ]
    }
  }
}
```

**Use Cases**:
- Identifying your most-trafficked internal systems
- Understanding service usage within a system
- Resource allocation and scaling decisions
- System health monitoring priorities

### Output Files

1. **Summary Report**: `multiple_teams_report.json` (or custom named)
   - Contains all domains analyzed
   - Both domain and system reports
   - Filter information if applied

2. **Individual Domain Reports**: `<Domain_Name>_consumer_report.json`
   - Separate report per domain
   - Detailed breakdown for that domain only

### External/Unknown Handling

Services that cannot be resolved to a known domain/product are categorized as "External/Unknown":

```json
{
  "External/Unknown": {
    "count": 0,
    "percentage": 0.0,
    "excluded_count": 56635,
    "details": [
      {
        "target_service": "your-service",
        "calling_service": "unresolved-service",
        "excluded_count": 50000
      }
    ]
  }
}
```

**Key Behaviors**:
- **Count is 0**: External/Unknown services don't affect totals
- **Percentage is 0%**: Excluded from percentage calculations
- **Excluded_count shows actual traffic**: The real call count is preserved in `excluded_count`
- **Presence of excluded_count**: Indicates this grouping is excluded from totals
- **Details use excluded_count**: Each detail entry uses `excluded_count` instead of `count`
- **Other percentages add to 100%**: Excluding External/Unknown

### Excluded Team Services

When using `--excludeSpecifiedTeamRequests`, services owned by the specified teams are excluded from totals but still appear in reports:

```json
{
  "team-product": {
    "percentage": 0.0,
    "excluded_count": 89,
    "details": [
      {
        "target_service": "service-a",
        "calling_service": "team-service-1",
        "excluded_count": 49
      },
      {
        "target_service": "service-b",
        "calling_service": "team-service-2",
        "excluded_count": 40
      }
    ]
  }
}
```

**Key Behaviors**:
- Services owned by excluded teams are NOT counted in totals
- The actual call counts are preserved in `excluded_count` fields
- The presence of `excluded_count` (instead of `count`) indicates these are excluded entries
- This allows you to see internal team traffic without skewing external consumer metrics

The presence of the `excluded_count` field (instead of `count`) indicates a consumer grouping that has traffic but is not included in the total calculations. The `excluded_count` field shows the actual traffic volume for reference, while `percentage: 0.0` indicate these are not included in aggregate metrics.

This allows you to see what's calling your services without skewing metrics with unidentified callers or internal team traffic.

## Features & Capabilities

### Product-Based Grouping
The tool intelligently groups consuming services by their **product** (with automatic fallback to **platform**, then **domain**).

#### Special Handling for "shared" Values

To avoid over-aggregation, "shared" values are handled specially:

1. **Both product="shared" AND platform="shared"**:
   - If business_unit is valid (not "shared") → Use business_unit
   - If business_unit is also "shared" → Use "shared"

2. **Only product="shared"**:
   - If business_unit is NOT "shared" → Skip product, fall through to platform
   - If business_unit is "shared" → Use "shared"

3. **Only platform="shared"**:
   - If business_unit is NOT "shared" → Skip platform, fall through to domain
   - If business_unit is "shared" → Use "shared"

**Examples**:
- `product="shared"`, `platform="shared"`, `business_unit="unit-a"` → Groups as "unit-a"
- `product="shared"`, `platform="platform-x"`, `business_unit="unit-b"` → Groups as "platform-x"
- `product="product-y"`, `platform="shared"`, `business_unit="unit-c"` → Groups as "product-y"
- `product="shared"`, `platform="shared"`, `business_unit="shared"` → Groups as "shared"

**Resolution Order**:
1. Check `desired-end-categorizations` regex patterns (case-insensitive)
2. Check `application-assignments` config for explicit product mapping
3. Look up product in attribution data (from `product` field)
4. Apply "shared" logic (skip if "shared" with non-shared business_unit)
5. If no valid product, try platform (apply "shared" logic)
6. If no valid platform, use domain
7. If none found, categorize as "External/Unknown"

**Example**:
- Service "billing-service" with product="billing" → grouped under "billing"
- Service "team-service" with product="shared", business_unit="Analytics" → grouped under platform/domain (skips "shared")
- Service "universal-service" with product="shared", business_unit="shared" → grouped under "shared" (both are shared)
- Service "platform-service" with no product but platform="core-platform" → grouped under "core-platform"
- Service "analytics-worker" with no product/platform but domain="Analytics" → grouped under "Analytics"
- Service "external-lib" with no data → grouped under "External/Unknown"

This provides better business-level visibility into which product areas are consuming your services, with platform as an intermediate level of granularity before falling back to domain-level grouping.

### Request Caching
- Caches Datadog API responses for 24 hours by default
- Significantly speeds up re-runs and debugging
- Cache stored in `requestCache/` directory
- Automatic cache expiration and cleanup
- Use `--nocache` flag to force fresh API requests while still updating cache
- Use `--ignoreCacheExpiry` flag to use expired cache data for historical analysis
- Cache can be manually cleared by deleting the `requestCache/` directory

**Cache Options**:
- **Normal mode**: Uses cache if fresh (< 24 hours old), queries API if expired
- **`--nocache`**: Bypasses cache entirely, always queries API, updates cache with new data
- **`--ignoreCacheExpiry`**: Uses cache regardless of age, useful for analyzing historical data without re-querying API

### Rate Limiting
- Respects Datadog API rate limits
- Configurable rate limit preservation
- Automatic retry on rate limit hits
- Visual countdown during rate limit waits

### Error Handling
- Retries on 500 Internal Server Error (3 attempts)
- Failed requests saved to `errors.json`
- Detailed error logging with timestamps
- Continues processing after individual failures

### Excluding Specified Team Requests
- When `--excludeSpecifiedTeamRequests` is enabled with teams specified (via `--teams` parameter or config file), any requests from services owned by those teams are ignored in all reporting
- This allows you to focus on external consumers or analyze only inbound traffic to your team's services
- Useful for understanding how external products/domains depend on your services without noise from internal team requests
- Must be used in conjunction with team filtering (either `--teams` parameter or "teams" in config file)

### Fuzzy Service Matching
The tool uses multiple strategies to match Datadog service names to your attribution data:

1. **Application-assignments first** (explicit config takes priority)
2. **Exact name match**
3. **Alias resolution** (from application-alias config)
4. **Suffix removal** (-service, -http-client, -lambda)
5. **Case-insensitive matching**
6. **Title field matching**
7. **Character substitution** (dashes to spaces)

### Colored Output
- Cyan: Information messages
- Green: Success messages
- Yellow: Warnings
- Red: Errors
- Color-coded progress tracking

## Workflow Example

### Complete Analysis Workflow

```bash
# Step 1: Generate team application attribution data
python teamApplicationAttribution.py > allTeamApplications.json

# Step 2: Set up configuration file
cat > ~/.datadog.cfg << EOF
{
  "api-key": "your_api_key",
  "app-key": "your_app_key",
  "application-assignments": [
    {
      "name": "external-library",
      "domain": "External/Unknown"
    }
  ],
  "skip-applications": ["test-service"]
}
EOF

# Step 3: Run analysis
python serviceConsumerAnalysis.py \
  allTeamApplications.json \
  production \
  https://company.datadoghq.com \
  --time-period 1w \
  --preserve-rate-limit 0

# Step 4: Review reports
cat multiple_teams_report.json | jq '.domain_reports'

# View specific domain report
cat Analytics_consumer_report.json | jq '.consumer_products'
```

### Sample Output Structure

**Individual Domain Report** (`Analytics_consumer_report.json`):
```json
{
  "domain": "Analytics",
  "consumer_products": {
    "billing": {
      "count": 15000,
      "percentage": 45.5,
      "details": [
        {
          "target_service": "analytics-api",
          "calling_service": "billing-service",
          "count": 10000
        },
        {
          "target_service": "analytics-worker",
          "calling_service": "billing-processor",
          "count": 5000
        }
      ]
    },
    "Platform": {
      "count": 8000,
      "percentage": 24.2,
      "details": [
        {
          "target_service": "analytics-api",
          "calling_service": "platform-gateway",
          "count": 8000
        }
      ]
    },
    "event-management": {
      "count": 10000,
      "percentage": 30.3,
      "details": [
        {
          "target_service": "analytics-stream",
          "calling_service": "event-processor",
          "count": 10000
        }
      ]
    }
  },
  "unique_consuming_products": 3,
  "consumer_by_system": {
    "analytics-platform": {
      "count": 20000,
      "percentage": 60.6,
      "services": [
        {
          "service": "analytics-api",
          "count": 18000
        },
        {
          "service": "analytics-worker",
          "count": 2000
        }
      ]
    },
    "analytics-streaming": {
      "count": 13000,
      "percentage": 39.4,
      "services": [
        {
          "service": "analytics-stream",
          "count": 13000
        }
      ]
    }
  }
}
```

Note: In this example:
- "billing" is a **product** (grouped from services with `product="billing"`)
- "Platform" could be a **platform** (fallback for services without product but with platform defined) or a **domain** (fallback when neither product nor platform is defined)
- "event-management" is a **product**

### Filtering for Specific Analysis

```bash
# Analyze specific teams
python serviceConsumerAnalysis.py \
  allTeamApplications.json \
  production \
  https://company.datadoghq.com \
  --teams "team1,team2,team3" \
  --time-period 2w

# Analyze single application
python serviceConsumerAnalysis.py \
  allTeamApplications.json \
  production \
  https://company.datadoghq.com \
  -a "service-a" \
  --time-period 1d

# Use expired cache for historical comparison
python serviceConsumerAnalysis.py \
  allTeamApplications.json \
  production \
  https://company.datadoghq.com \
  --ignoreCacheExpiry \
  --output historical_analysis.json

# Analyze teams excluding their own internal requests (command line teams)
python serviceConsumerAnalysis.py \
  allTeamApplications.json \
  production \
  https://company.datadoghq.com \
  --teams "team1,team2" \
  --excludeSpecifiedTeamRequests \
  --time-period 1w

# Analyze teams from config file, excluding their internal requests
python serviceConsumerAnalysis.py \
  allTeamApplications.json \
  production \
  https://company.datadoghq.com \
  --excludeSpecifiedTeamRequests \
  --time-period 1w
```

**Note**: When `--excludeSpecifiedTeamRequests` is used, requests originating from services owned by the specified teams (from `--teams` parameter or config file) will be excluded from all totals, percentages, and details in the reports.

## Troubleshooting

### Common Issues

#### 1. Authentication Failures
**Problem**: 401 Unauthorized errors
**Solution**:
- Verify API keys in `.datadog.cfg` or command line
- Ensure keys have necessary permissions
- Check for typos in credentials

#### 2. Service Not Found / External/Unknown
**Problem**: Services show up as "External/Unknown"
**Solutions**:
- Add service to `application-assignments` in `.datadog.cfg`
- Check service name matches between Datadog and attribution data
- Use `application-alias` to map Datadog names to attribution names
- Verify fuzzy matching patterns (check for unusual suffixes)

#### 3. Rate Limit Issues
**Problem**: Frequent rate limit hits
**Solutions**:
- Increase `--preserve-rate-limit` value
- Use smaller time periods (`--time-period 1h` instead of `2w`)
- Filter to specific teams/applications
- Enable caching to avoid redundant requests

#### 4. Missing Services in Reports
**Problem**: Expected services don't appear
**Solutions**:
- Check if service is in `skip-applications`
- Verify service has traffic in the specified time period
- Confirm environment name matches Datadog environment
- Check service lifecycle status (only active services by default)

#### 5. Percentage Doesn't Add to 100%
**Problem**: Percentages seem incorrect
**Solution**: This is expected - "External/Unknown" is excluded from totals to prevent skewing metrics with unidentified callers

#### 6. Understanding Product vs Platform vs Domain Grouping
**Question**: Why do I see product names, platform names, and domain names in `consumer_products`?
**Explanation**: 
- Services with a defined `product` field (except "shared" in certain cases) are grouped by their product name (e.g., "billing", "event-management")
- Services with product="shared" are handled specially:
  - If business_unit is also "shared", the service is grouped under "shared"
  - If business_unit is NOT "shared", it falls through to platform or domain
- Services without a product but with a `platform` are grouped by their platform name (e.g., "core-platform", "data-platform")
- Services with neither product nor platform are grouped by their `domain` (e.g., "Analytics", "Platform")
- This provides the best available business-level view of consumption patterns with intermediate granularity
- To see only product-based grouping, ensure all services have a meaningful `product` defined in attribution data or `application-assignments`

#### 7. Excluded Team Requests Not Appearing
**Problem**: Requests from specified teams are missing in reports
**Solution**: This is expected when `--excludeSpecifiedTeamRequests` is used. These requests are intentionally excluded from analysis to focus on external consumers or avoid internal cross-team traffic.

### Debug Tips

1. **Check cache directory**: Look in `requestCache/` for cached responses
2. **Review errors.json**: Contains details of failed API requests
3. **Use smaller filters**: Test with single team/application first
4. **Enable verbose output**: Script prints detailed progress information
5. **Verify input data**: Confirm `allTeamApplications.json` structure is valid

## Best Practices

1. **Use configuration file**: Store credentials and mappings in `~/.datadog.cfg`
2. **Start with longer periods**: Use `--time-period 1w` or `2w` for comprehensive view
3. **Map external services**: Add common external services to `application-assignments`
4. **Skip noise**: Use `skip-applications` to exclude test/monitoring services
5. **Filter iteratively**: Start broad, then narrow with team/application filters
6. **Review External/Unknown**: Check these entries to identify unmapped services
7. **Cache management**: Delete `requestCache/` if data is stale or incorrect
8. **Version control config**: Keep `.datadog.cfg` template in your repo (without credentials)

## Advanced Usage

### Custom Output Directory
Reports are generated in the current directory by default. Change directory before running:
```bash
mkdir -p reports/$(date +%Y-%m-%d)
cd reports/$(date +%Y-%m-%d)
python ../../serviceConsumerAnalysis.py ...
```

### Automated Reporting
```bash
#!/bin/bash
# Weekly analysis script

DATE=$(date +%Y-%m-%d)
OUTPUT_DIR="reports/$DATE"
mkdir -p "$OUTPUT_DIR"

python serviceConsumerAnalysis.py \
  allTeamApplications.json \
  production \
  https://company.datadoghq.com \
  --time-period 1w \
  --preserve-rate-limit 0 \
  > "$OUTPUT_DIR/analysis.log" 2>&1

# Move reports to dated directory
mv *_report.json "$OUTPUT_DIR/"

echo "Analysis complete. Reports in $OUTPUT_DIR"
```

### Comparing Time Periods
```bash
# Week 1
python serviceConsumerAnalysis.py ... --time-period 1w
mv multiple_teams_report.json week1_report.json

# Week 2 (after 1 week)
python serviceConsumerAnalysis.py ... --time-period 1w
mv multiple_teams_report.json week2_report.json

# Compare specific domain
jq '.domain_reports."Domain A"' week1_report.json > week1_domain.json
jq '.domain_reports."Domain A"' week2_report.json > week2_domain.json
diff week1_domain.json week2_domain.json
```

## Summary

`serviceConsumerAnalysis.py` provides comprehensive visibility into your microservices architecture by analyzing Datadog trace data and generating reports on service consumption patterns. With features like intelligent fuzzy matching, configurable mappings, rate limiting, and caching, it's designed for efficient and reliable analysis of complex service ecosystems.

For questions or issues, refer to the inline script documentation or contact your platform team.
