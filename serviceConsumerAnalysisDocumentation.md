# Service Consumer Analysis Documentation

## Overview

`serviceConsumerAnalysis.py` is a powerful tool for analyzing service-to-service communication patterns in your microservices architecture using Datadog trace data. It identifies which services are calling your team's applications and generates comprehensive reports organized by domain with consumers grouped by product.

The tool takes team application attribution data (from `teamApplicationAttribution.py`) and queries Datadog's APM traces to discover consumption patterns, helping you understand:
- Which products/business areas are consuming your services
- Which of your internal systems receive the most traffic
- Cross-domain dependencies and communication patterns
- External service usage that may need mapping

**Key Feature**: Reports are organized by **domain** (one file per domain), but within each report, consumers are intelligently grouped by their **product** (with automatic fallback to domain if no product is defined).

## Prerequisites

1. **Python 3.x** with required packages:
   - `requests` - HTTP client for Datadog API
   - `colorama` - Colored terminal output

2. **Datadog Access**:
   - API Key and Application Key, OR
   - Valid authentication cookies

3. **Input Data**:
   - `allTeamApplications.json` - Generated by `teamApplicationAttribution.py`
   - `.datadog.cfg` - Configuration file (optional but recommended)

## Command Line Usage

### Basic Syntax

```bash
python serviceConsumerAnalysis.py <input_file> <environment> <datadog_host> [auth_options] [filters]
```

### Parameters

- **`<input_file>`** (required): Path to the JSON file containing team application attribution data
- **`<environment>`** (required): Datadog environment to query (e.g., `production`, `staging`)
- **`<datadog_host>`** (required): Your Datadog site URL (e.g., `https://company.datadoghq.com`)

### Authentication Options

Choose one of the following:

#### Option 1: API Keys (Recommended)
```bash
--api-key <YOUR_API_KEY> --app-key <YOUR_APP_KEY>
```

#### Option 2: Configuration File (Most Convenient)
If you omit `--api-key` and `--app-key`, credentials are automatically read from `~/.datadog.cfg`

#### Option 3: Cookie Authentication
```bash
--cookies "<cookie_string>"
```
Cookies should be semicolon-separated (e.g., `"_dd_did=...; datadog-theme=light"`)

### Optional Filters

- **`-t, --teams <TEAMS>`**: Process only specific teams (comma-separated)
  ```bash
  -t "team1,team2,team3"
  ```

- **`-a, --applications <APPS>`**: Process only specific applications (comma-separated)
  ```bash
  -a "service-a,service-b"
  ```

### Additional Options

- **`--time-period <PERIOD>`**: Time window for analysis (default: `1h`)
  - Valid values: `1h`, `4h`, `1d`, `1w`, `2w`, etc.
  ```bash
  --time-period 2w
  ```

- **`--preserve-rate-limit <N>`**: Number of API requests to preserve from rate limit (default: `1`)
  ```bash
  --preserve-rate-limit 0  # Use full rate limit
  ```

- **`--nocache`**: Disable reading from cache (still writes to cache for future runs)
  - Forces fresh API requests even if cached data exists
  - Useful when you need the most current data or suspect cache is stale
  ```bash
  --nocache
  ```

- **`--ignoreCacheExpiry`**: Use cached data without checking expiration time
  - Reads and uses cache even if older than 24 hours
  - Useful for analyzing historical data or reproducing past analysis
  - Does not query Datadog API, relies entirely on cached responses
  - Helpful when rate limits are a concern or API is unavailable
  ```bash
  --ignoreCacheExpiry
  ```

- **`--output <FILE>`**: Custom name for the summary report (default: `multiple_teams_report.json`)
  ```bash
  --output custom_report.json
  ```

- **`--excludeSpecifiedTeamRequests`**: When used with `--teams`, excludes requests from services owned by those teams from all reporting and analysis
  - Only valid when `--teams` is specified
  - Useful for focusing analysis on external consumers or avoiding internal cross-team traffic
  - Any request from a service owned by one of the specified teams is ignored/excluded during processing
  ```bash
  --teams "team1,team2" --excludeSpecifiedTeamRequests
  ```

### Examples

**1. Basic usage with config file authentication:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com
```

**2. Analyze specific teams with 2-week time window:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com \
  --time-period 2w \
  --teams "team1,team2,team3"
```

**3. Single application analysis with explicit API keys:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com \
  --api-key YOUR_API_KEY \
  --app-key YOUR_APP_KEY \
  -a "service-a"
```

**4. Using cookie authentication:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com \
  --cookies "_dd_did=...; datadog-theme=light; dogweb=..."
```

**5. Force fresh data by disabling cache:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com \
  --nocache
```

**6. Use expired cache data for historical analysis:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com \
  --ignoreCacheExpiry
```

**7. Analyze specific teams, excluding their own requests:**
```bash
python serviceConsumerAnalysis.py allTeamApplications.json production https://company.datadoghq.com \
  --teams "team1,team2" \
  --excludeSpecifiedTeamRequests
```

## Configuration File: ~/.datadog.cfg

The `.datadog.cfg` file is a JSON configuration file stored in your home directory that provides credentials, service mappings, and advanced configuration options.

### File Location
```
~/.datadog.cfg
```

### Configuration Structure

```json
{
  "api-key": "your_datadog_api_key",
  "app-key": "your_datadog_app_key",
  "application-alias": {
    "service1": "service2",
    "another-service": "canonical-service"
  },
  "skip-applications": [
    "test-service",
    "deprecated-service",
    "internal-tool"
  ],
  "application-assignments": [
    {
      "name": "external-service-name",
      "business-unit": "business-unit-name",
      "domain": "domain-name",
      "platform": "platform-name",
      "product": null,
      "system": null
    }
  ]
}
```

### Configuration Sections

#### 1. Authentication (Required)
```json
{
  "api-key": "your_datadog_api_key",
  "app-key": "your_datadog_app_key"
}
```
- Stores your Datadog API credentials
- Eliminates need to pass credentials on command line

#### 2. Application Alias (Optional)
```json
{
  "application-alias": {
    "service-a-v2": "service-a",
    "service-b-alt": "service-b"
  }
}
```

**Purpose**: Maps service names to use metadata from another service while maintaining their original identity.

**Use Cases**:
- Service names in Datadog differ from canonical names
- Multiple services share the same team/domain metadata
- Temporary services that should map to permanent counterparts

**Behavior**:
- Lookup uses the aliased service's business-unit, domain, platform, product, and system data
- Reports still identify the service by its original name
- Alias resolution happens **after** application-assignments check

**Example**: If "service-a-v2" is aliased to "service-a":
- Service "service-a-v2" in Datadog traces
- Lookup finds "service-a" in attribution data
- Uses service-a's domain/team information
- Reports show "service-a-v2" as the service name

#### 3. Skip Applications (Optional)
```json
{
  "skip-applications": [
    "test-service",
    "deprecated-service",
    "internal-monitoring-tool"
  ]
}
```

**Purpose**: Completely exclude specified services from all processing and calculations.

**Behavior**:
- Services in this list are never queried
- Calls involving these services (as caller or callee) are ignored
- These services **do not affect** totals, percentages, or any aggregated data
- Useful for removing noise from reports

**Use Cases**:
- Test/development services in production traces
- Deprecated services being phased out
- Internal monitoring tools that skew metrics

#### 4. Application Assignments (Optional)
```json
{
  "application-assignments": [
    {
      "name": "external-library",
      "business-unit": "shared",
      "domain": "External/Unknown",
      "platform": "external",
      "product": null,
      "system": null
    },
    {
      "name": "third-party-service",
      "business-unit": "shared",
      "domain": "Domain A",
      "platform": "platform-x",
      "product": "product-y",
      "system": "system-z"
    }
  ]
}
```

**Purpose**: Provides explicit domain/team assignments for services not found in attribution data.

**Priority**: **Checked FIRST** before attempting fuzzy matching or attribution data lookup.

**Use Cases**:
- External services not in your team application catalog
- Third-party integrations (libraries, SDKs, monitoring tools, etc.)
- Services that fuzzy matching cannot resolve
- Override incorrect attribution data

**Behavior**:
1. When a service is encountered, check application-assignments first
2. If found, use the configured metadata immediately
3. If not found, proceed with fuzzy matching against attribution data
4. If still not found, mark as "External/Unknown"

## Input Data: allTeamApplications.json

This file is generated by `teamApplicationAttribution.py` and contains your organization's team and application structure.

### File Structure

```json
{
  "team-identifier": {
    "team_name": "team-identifier",
    "team_title": "Team Display Name",
    "domain": "Domain Name",
    "business_unit": "business-unit-name",
    "applications": [
      {
        "name": "service-name",
        "title": "Service Display Title",
        "type": "application",
        "lifecycle": "active",
        "system": "system-name",
        "platform": "platform-name",
        "product": "product-name",
        "business_unit": "business-unit-name",
        "description": "Service description"
      }
    ]
  }
}
```

### Key Fields

- **`team_name`**: Unique team identifier
- **`team_title`**: Human-readable team name
- **`domain`**: Business domain the team belongs to
- **`business_unit`**: Higher-level organizational grouping
- **`applications`**: Array of services owned by the team
  - **`name`**: Service name (used for matching with Datadog)
  - **`title`**: Display name for the service
  - **`system`**: System the service belongs to within the domain
  - **`lifecycle`**: Service lifecycle status (active, deprecated, etc.)

### Service Name Matching

The tool uses intelligent fuzzy matching to resolve Datadog service names to attribution data:

1. **Exact match**: Direct name match
2. **Suffix removal**: Tries removing common suffixes:
   - `-service`
   - `-http-client`
   - `-lambda`
3. **Character substitution**: Replaces dashes with spaces
4. **Title matching**: Checks against the service `title` field
5. **Case-insensitive**: All matches are case-insensitive
6. **Alias resolution**: Applies application-alias mappings

**Example Matches**:
- `service-a-v2` → `service-a` (exact match or suffix removal)
- `service-b` → `service-b` (exact match)
- `service-c-http-client` → `service-c` (suffix removal)
- `service-d-lambda` → `service-d` (suffix removal)

## Output Reports

The tool generates JSON reports with two main views of your service consumption patterns. Reports are organized by **domain** (one file per domain), with consumers intelligently grouped by their **product** (or domain if no product is defined).

### Report Types

#### 1. Domain Reports (`domain_reports`)
Shows **WHO is calling your services**, organized by the target domain with consumers grouped by their product.

**Structure**:
```json
{
  "Target Domain": {
    "Consumer Product": {
      "count": 1000,
      "percentage": 30.5,
      "details": [
        {
          "target_service": "your-service",
          "calling_service": "their-service",
          "count": 500
        }
      ]
    }
  }
}
```

**Key Feature**: Consumers are grouped by their **product** (e.g., "billing", "event-management") if available. If a consuming service doesn't have a product defined, it falls back to the **domain** (e.g., "Analytics", "Platform").

**Use Cases**:
- Understanding which products/business areas depend on your services
- Identifying cross-product dependencies
- Planning API changes and deprecations based on product impact
- Capacity planning based on consumer patterns

#### 2. System Reports (`system_reports`)
Shows **WHICH of your systems are being called**, aggregated by system within your domain.

**Structure**:
```json
{
  "Target Domain": {
    "System Name": {
      "count": 5000,
      "percentage": 45.2,
      "services": [
        {
          "service": "service-x",
          "count": 3000
        }
      ]
    }
  }
}
```

**Use Cases**:
- Identifying your most-trafficked internal systems
- Understanding service usage within a system
- Resource allocation and scaling decisions
- System health monitoring priorities

### Output Files

1. **Summary Report**: `multiple_teams_report.json` (or custom named)
   - Contains all domains analyzed
   - Both domain and system reports
   - Filter information if applied

2. **Individual Domain Reports**: `<Domain_Name>_consumer_report.json`
   - Separate report per domain
   - Detailed breakdown for that domain only

### External/Unknown Handling

Services that cannot be resolved to a known domain/product are categorized as "External/Unknown":

```json
{
  "External/Unknown": {
    "count": 0,
    "percentage": 0.0,
    "details": [
      {
        "target_service": "your-service",
        "calling_service": "unresolved-service",
        "count": 50000
      }
    ]
  }
}
```

**Key Behaviors**:
- **Count is 0**: External/Unknown services don't affect totals
- **Percentage is 0%**: Excluded from percentage calculations
- **Details preserved**: Actual call counts saved for reference
- **Other percentages add to 100%**: Excluding External/Unknown

This allows you to see what's calling your services without skewing metrics with unidentified callers.

## Features & Capabilities

### Product-Based Grouping
The tool intelligently groups consuming services by their **product** (with automatic fallback to **platform**, then **domain**).

#### Special Handling for "shared" Values

To avoid over-aggregation, "shared" values are handled specially:

1. **Both product="shared" AND platform="shared"**:
   - If business_unit is valid (not "shared") → Use business_unit
   - If business_unit is also "shared" → Use "shared"

2. **Only product="shared"**:
   - If business_unit is NOT "shared" → Skip product, fall through to platform
   - If business_unit is "shared" → Use "shared"

3. **Only platform="shared"**:
   - If business_unit is NOT "shared" → Skip platform, fall through to domain
   - If business_unit is "shared" → Use "shared"

**Examples**:
- `product="shared"`, `platform="shared"`, `business_unit="unit-a"` → Groups as "unit-a"
- `product="shared"`, `platform="platform-x"`, `business_unit="unit-b"` → Groups as "platform-x"
- `product="product-y"`, `platform="shared"`, `business_unit="unit-c"` → Groups as "product-y"
- `product="shared"`, `platform="shared"`, `business_unit="shared"` → Groups as "shared"

**Resolution Order**:
1. Check `desired-end-categorizations` regex patterns (case-insensitive)
2. Check `application-assignments` config for explicit product mapping
3. Look up product in attribution data (from `product` field)
4. Apply "shared" logic (skip if "shared" with non-shared business_unit)
5. If no valid product, try platform (apply "shared" logic)
6. If no valid platform, use domain
7. If none found, categorize as "External/Unknown"

**Example**:
- Service "billing-service" with product="billing" → grouped under "billing"
- Service "team-service" with product="shared", business_unit="Analytics" → grouped under platform/domain (skips "shared")
- Service "universal-service" with product="shared", business_unit="shared" → grouped under "shared" (both are shared)
- Service "platform-service" with no product but platform="core-platform" → grouped under "core-platform"
- Service "analytics-worker" with no product/platform but domain="Analytics" → grouped under "Analytics"
- Service "external-lib" with no data → grouped under "External/Unknown"

This provides better business-level visibility into which product areas are consuming your services, with platform as an intermediate level of granularity before falling back to domain-level grouping.

### Request Caching
- Caches Datadog API responses for 24 hours by default
- Significantly speeds up re-runs and debugging
- Cache stored in `requestCache/` directory
- Automatic cache expiration and cleanup
- Use `--nocache` flag to force fresh API requests while still updating cache
- Use `--ignoreCacheExpiry` flag to use expired cache data for historical analysis
- Cache can be manually cleared by deleting the `requestCache/` directory

**Cache Options**:
- **Normal mode**: Uses cache if fresh (< 24 hours old), queries API if expired
- **`--nocache`**: Bypasses cache entirely, always queries API, updates cache with new data
- **`--ignoreCacheExpiry`**: Uses cache regardless of age, useful for analyzing historical data without re-querying API

### Rate Limiting
- Respects Datadog API rate limits
- Configurable rate limit preservation
- Automatic retry on rate limit hits
- Visual countdown during rate limit waits

### Error Handling
- Retries on 500 Internal Server Error (3 attempts)
- Failed requests saved to `errors.json`
- Detailed error logging with timestamps
- Continues processing after individual failures

### Excluding Specified Team Requests
- When `--excludeSpecifiedTeamRequests` is enabled (with `--teams`), any requests from services owned by those teams are ignored in all reporting
- This allows you to focus on external consumers or analyze only inbound traffic to your team's services
- Useful for understanding how external products/domains depend on your services without noise from internal team requests
- Must be used in conjunction with the `--teams` filter

### Fuzzy Service Matching
The tool uses multiple strategies to match Datadog service names to your attribution data:

1. **Application-assignments first** (explicit config takes priority)
2. **Exact name match**
3. **Alias resolution** (from application-alias config)
4. **Suffix removal** (-service, -http-client, -lambda)
5. **Case-insensitive matching**
6. **Title field matching**
7. **Character substitution** (dashes to spaces)

### Colored Output
- Cyan: Information messages
- Green: Success messages
- Yellow: Warnings
- Red: Errors
- Color-coded progress tracking

## Workflow Example

### Complete Analysis Workflow

```bash
# Step 1: Generate team application attribution data
python teamApplicationAttribution.py > allTeamApplications.json

# Step 2: Set up configuration file
cat > ~/.datadog.cfg << EOF
{
  "api-key": "your_api_key",
  "app-key": "your_app_key",
  "application-assignments": [
    {
      "name": "external-library",
      "domain": "External/Unknown"
    }
  ],
  "skip-applications": ["test-service"]
}
EOF

# Step 3: Run analysis
python serviceConsumerAnalysis.py \
  allTeamApplications.json \
  production \
  https://company.datadoghq.com \
  --time-period 1w \
  --preserve-rate-limit 0

# Step 4: Review reports
cat multiple_teams_report.json | jq '.domain_reports'

# View specific domain report
cat Analytics_consumer_report.json | jq '.consumer_products'
```

### Sample Output Structure

**Individual Domain Report** (`Analytics_consumer_report.json`):
```json
{
  "domain": "Analytics",
  "consumer_products": {
    "billing": {
      "count": 15000,
      "percentage": 45.5,
      "details": [
        {
          "target_service": "analytics-api",
          "calling_service": "billing-service",
          "count": 10000
        },
        {
          "target_service": "analytics-worker",
          "calling_service": "billing-processor",
          "count": 5000
        }
      ]
    },
    "Platform": {
      "count": 8000,
      "percentage": 24.2,
      "details": [
        {
          "target_service": "analytics-api",
          "calling_service": "platform-gateway",
          "count": 8000
        }
      ]
    },
    "event-management": {
      "count": 10000,
      "percentage": 30.3,
      "details": [
        {
          "target_service": "analytics-stream",
          "calling_service": "event-processor",
          "count": 10000
        }
      ]
    }
  },
  "unique_consuming_products": 3,
  "consumer_by_system": {
    "analytics-platform": {
      "count": 20000,
      "percentage": 60.6,
      "services": [
        {
          "service": "analytics-api",
          "count": 18000
        },
        {
          "service": "analytics-worker",
          "count": 2000
        }
      ]
    },
    "analytics-streaming": {
      "count": 13000,
      "percentage": 39.4,
      "services": [
        {
          "service": "analytics-stream",
          "count": 13000
        }
      ]
    }
  }
}
```

Note: In this example:
- "billing" is a **product** (grouped from services with `product="billing"`)
- "Platform" could be a **platform** (fallback for services without product but with platform defined) or a **domain** (fallback when neither product nor platform is defined)
- "event-management" is a **product**

### Filtering for Specific Analysis

```bash
# Analyze specific teams
python serviceConsumerAnalysis.py \
  allTeamApplications.json \
  production \
  https://company.datadoghq.com \
  --teams "team1,team2,team3" \
  --time-period 2w

# Analyze single application
python serviceConsumerAnalysis.py \
  allTeamApplications.json \
  production \
  https://company.datadoghq.com \
  -a "service-a" \
  --time-period 1d

# Use expired cache for historical comparison
python serviceConsumerAnalysis.py \
  allTeamApplications.json \
  production \
  https://company.datadoghq.com \
  --ignoreCacheExpiry \
  --output historical_analysis.json

# Analyze teams excluding their own internal requests
python serviceConsumerAnalysis.py \
  allTeamApplications.json \
  production \
  https://company.datadoghq.com \
  --teams "team1,team2" \
  --excludeSpecifiedTeamRequests \
  --time-period 1w
```

**Note**: When `--excludeSpecifiedTeamRequests` is used, requests originating from services owned by the specified teams will be excluded from all totals, percentages, and details in the reports.

## Troubleshooting

### Common Issues

#### 1. Authentication Failures
**Problem**: 401 Unauthorized errors
**Solution**:
- Verify API keys in `.datadog.cfg` or command line
- Ensure keys have necessary permissions
- Check for typos in credentials

#### 2. Service Not Found / External/Unknown
**Problem**: Services show up as "External/Unknown"
**Solutions**:
- Add service to `application-assignments` in `.datadog.cfg`
- Check service name matches between Datadog and attribution data
- Use `application-alias` to map Datadog names to attribution names
- Verify fuzzy matching patterns (check for unusual suffixes)

#### 3. Rate Limit Issues
**Problem**: Frequent rate limit hits
**Solutions**:
- Increase `--preserve-rate-limit` value
- Use smaller time periods (`--time-period 1h` instead of `2w`)
- Filter to specific teams/applications
- Enable caching to avoid redundant requests

#### 4. Missing Services in Reports
**Problem**: Expected services don't appear
**Solutions**:
- Check if service is in `skip-applications`
- Verify service has traffic in the specified time period
- Confirm environment name matches Datadog environment
- Check service lifecycle status (only active services by default)

#### 5. Percentage Doesn't Add to 100%
**Problem**: Percentages seem incorrect
**Solution**: This is expected - "External/Unknown" is excluded from totals to prevent skewing metrics with unidentified callers

#### 6. Understanding Product vs Platform vs Domain Grouping
**Question**: Why do I see product names, platform names, and domain names in `consumer_products`?
**Explanation**: 
- Services with a defined `product` field (except "shared" in certain cases) are grouped by their product name (e.g., "billing", "event-management")
- Services with product="shared" are handled specially:
  - If business_unit is also "shared", the service is grouped under "shared"
  - If business_unit is NOT "shared", it falls through to platform or domain
- Services without a product but with a `platform` are grouped by their platform name (e.g., "core-platform", "data-platform")
- Services with neither product nor platform are grouped by their `domain` (e.g., "Analytics", "Platform")
- This provides the best available business-level view of consumption patterns with intermediate granularity
- To see only product-based grouping, ensure all services have a meaningful `product` defined in attribution data or `application-assignments`

#### 7. Excluded Team Requests Not Appearing
**Problem**: Requests from specified teams are missing in reports
**Solution**: This is expected when `--excludeSpecifiedTeamRequests` is used. These requests are intentionally excluded from analysis to focus on external consumers or avoid internal cross-team traffic.

### Debug Tips

1. **Check cache directory**: Look in `requestCache/` for cached responses
2. **Review errors.json**: Contains details of failed API requests
3. **Use smaller filters**: Test with single team/application first
4. **Enable verbose output**: Script prints detailed progress information
5. **Verify input data**: Confirm `allTeamApplications.json` structure is valid

## Best Practices

1. **Use configuration file**: Store credentials and mappings in `~/.datadog.cfg`
2. **Start with longer periods**: Use `--time-period 1w` or `2w` for comprehensive view
3. **Map external services**: Add common external services to `application-assignments`
4. **Skip noise**: Use `skip-applications` to exclude test/monitoring services
5. **Filter iteratively**: Start broad, then narrow with team/application filters
6. **Review External/Unknown**: Check these entries to identify unmapped services
7. **Cache management**: Delete `requestCache/` if data is stale or incorrect
8. **Version control config**: Keep `.datadog.cfg` template in your repo (without credentials)

## Advanced Usage

### Custom Output Directory
Reports are generated in the current directory by default. Change directory before running:
```bash
mkdir -p reports/$(date +%Y-%m-%d)
cd reports/$(date +%Y-%m-%d)
python ../../serviceConsumerAnalysis.py ...
```

### Automated Reporting
```bash
#!/bin/bash
# Weekly analysis script

DATE=$(date +%Y-%m-%d)
OUTPUT_DIR="reports/$DATE"
mkdir -p "$OUTPUT_DIR"

python serviceConsumerAnalysis.py \
  allTeamApplications.json \
  production \
  https://company.datadoghq.com \
  --time-period 1w \
  --preserve-rate-limit 0 \
  > "$OUTPUT_DIR/analysis.log" 2>&1

# Move reports to dated directory
mv *_report.json "$OUTPUT_DIR/"

echo "Analysis complete. Reports in $OUTPUT_DIR"
```

### Comparing Time Periods
```bash
# Week 1
python serviceConsumerAnalysis.py ... --time-period 1w
mv multiple_teams_report.json week1_report.json

# Week 2 (after 1 week)
python serviceConsumerAnalysis.py ... --time-period 1w
mv multiple_teams_report.json week2_report.json

# Compare specific domain
jq '.domain_reports."Domain A"' week1_report.json > week1_domain.json
jq '.domain_reports."Domain A"' week2_report.json > week2_domain.json
diff week1_domain.json week2_domain.json
```

## Summary

`serviceConsumerAnalysis.py` provides comprehensive visibility into your microservices architecture by analyzing Datadog trace data and generating reports on service consumption patterns. With features like intelligent fuzzy matching, configurable mappings, rate limiting, and caching, it's designed for efficient and reliable analysis of complex service ecosystems.

For questions or issues, refer to the inline script documentation or contact your platform team.
